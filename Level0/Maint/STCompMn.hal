external procedure BackDatStock(string,string,string,var val,Date,Integer);
external function Boolean TestArtCodeMatch(string,string);
external procedure FindStockValueAtPosition(string,string,string,var record PISVc);
external function string 255 FindINObjects(string,string);
external procedure FindPUStockAcc(string,record CostAccBlock,string,string,string,record INVc,Integer,var string,var string,Boolean);
external function val FindSerialNrQty(string,string,string);
external procedure CheckFlush(var Integer,Integer);
external function val DivRateToBase1(string,val,val,val,val,val,val,roundmode);
external function Boolean ReadFirstItem(string,var record INVc,Boolean,Boolean);
external function val GetStockQty(string,string,Date,Boolean);
external function Boolean FindItemVAR(string,var string,var string,var string,var string);
external function Boolean GetFirstItem(var string,var record INVc);
external procedure SDSumUp(var record SDVc);
external function Boolean GetFirstPurchaseItem2(string,string,string,var record PIVc);
external procedure CalculatePURowSum(val,val,string,var val,val,
                                     val,val,val,val,val,
                                     string,var val,Boolean,string,
                                     val,val,val,val,val);

external procedure PUSumUp(var record PUVc);
external procedure PUCalcCostPrice(string,val,Integer,Integer,string,string,
                          val,val,val,val,val,
                          val,val,val,val,val,val,
                          string,var val,val,var val,string,Integer);
external function Boolean SetInSet2(string,string);
external procedure ItemClassTypef(string,string,var Boolean);
external function val StringToValue(string,Integer,string,string); //EBS
external function val AbsoluteVal(val); //EBS
external procedure PUCalcCostPrice(string,val,Integer,Integer,string,string,
                                   val,val,val,val,val,
                                   val,val,val,val,val,val,
                                   string,var val,val,var val,string,Integer);
external function Boolean PUDchrsum(record PUVc,Integer);

global
function val STCompFindSerialNrQty(string artcode,string variety,string serialnr,string location,string position,var string resserialnr)
begin
  val instock,q;
  Boolean foundih,testf;
  record ItemHistVc IHr;
  
  resserialnr = "";
  if (blank(position)) then begin
    instock = FindSerialNrQty(artcode & variety,serialnr,location);
  end else begin
    foundih = true;
    IHr.Position = position;
    IHr.ArtCode = artcode;
    while (LoopKey("Position",IHr,2,foundih)) begin
      if (IHr.Position!=position) then begin foundih = false; end;
      if (IHr.ArtCode!=artcode) then begin foundih = false; end;
      if (foundih) then begin
        testf = true;
        if (nonblank(serialnr)) then begin
          if (IHr.SerialNr!=serialnr) then begin testf = false; end;
        end;
        if (nonblank(variety)) then begin
          if (IHr.Variety!=variety) then begin testf = false; end;
        end;
        if (testf) then begin
          instock = instock + IHr.RemQty;
          resserialnr = IHr.SerialNr;
        end;
      end;
    end;
  end;
  STCompFindSerialNrQty = instock;
  return;
end;

function string 20 GetUsageVarianceAcc(string itgroup,string defCostAcc)
BEGIN
  string 20 res;
  record ITVc ITr;
  record CostAccBlock CostAccRec;

  BlockLoad(CostAccRec);
  if (CostAccRec.ItemGroupAccounts!=0) then begin
    ITr.Code = itgroup;
    if (ReadFirstMain(ITr,1,true)) then begin
      res = ITr.UsageVarianceAcc;
    end;  
  end;
  if (blank(res)) then begin
    res = defCostAcc;
  end;
  GetUsageVarianceAcc = res;
  RETURN;
END;

function string 60 GetLocationObject(string location)
BEGIN
  string 20 res;
  record LocationVc Locr;

  Locr.Code = location;
  if (ReadFirstMain(Locr,1,true)) then begin
    res = Locr.Objects;
  end;
  GetLocationObject = res;
  RETURN;
END;

procedure RemoveFromLastSTForItem(string item,string position,var record StockTakeVc resStockTaker)
begin
  Integer resi,resrwcnt;
  row StockTakeVc resStockTakerw;

  resrwcnt = MatRowCnt(resStockTaker);
  for (resi=0;resi<resrwcnt;resi=resi+1) begin
    MatRowGet(resStockTaker,resi,resStockTakerw);
    if (item==resStockTakerw.ArtCode) and (position==resStockTakerw.Position) then begin
      MatRowDelete(resStockTaker,resi);
      goto LRemoveFromLastSTForItem;
    end;
  end;
LRemoveFromLastSTForItem:;  
  return;
end;
    
/*       
procedure CombineStockTake(string item,record StockTakeVc StockTaker,var record StockTakeVc resStockTaker)
begin
  Integer i,rwcnt;
  Integer resi,resrwcnt;
  row StockTakeVc StockTakerw;
  row StockTakeVc resStockTakerw;
  string 255 variety;
  
  rwcnt = MatRowCnt(StockTaker);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StockTaker,i,StockTakerw);
    variety = right(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(item));
    if (item==Left(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(variety))) then begin 
      resrwcnt = MatRowCnt(resStockTaker);
      if (resrwcnt==0) then begin
        CopyRow(StockTaker,StockTakerw,resStockTakerw);
LogText(0,"1.resStockTakerw.ArtCode " & resStockTakerw.ArtCode & " resStockTakerw.Position " & resStockTakerw.Position & " resStockTakerw.Qty " & resStockTakerw.Qty & " resrwcnt " & resrwcnt);
        MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
      end else begin
        for (resi=0;resi<resrwcnt;resi=resi+1) begin
          MatRowGet(resStockTaker,resi,resStockTakerw);
          if (StockTakerw.ArtCode==resStockTakerw.ArtCode) and (StockTakerw.SerialNr==resStockTakerw.SerialNr) and (StockTakerw.Position==resStockTakerw.Position) then begin
            resStockTakerw.Qty = resStockTakerw.Qty + StockTakerw.Qty;
            resStockTakerw.InStock = resStockTakerw.InStock + StockTakerw.InStock;
LogText(0,"2.resStockTakerw.ArtCode " & resStockTakerw.ArtCode & " resStockTakerw.Position " & resStockTakerw.Position & " resStockTakerw.Qty " & resStockTakerw.Qty & " resi " & resi);
            MatRowPut(resStockTaker,resi,resStockTakerw);
          end else begin
            CopyRow(StockTaker,StockTakerw,resStockTakerw);
            MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
            resi = resrwcnt;
LogText(0,"3.resStockTakerw.ArtCode " & resStockTakerw.ArtCode & " resStockTakerw.Position " & resStockTakerw.Position & " resStockTakerw.Qty " & resStockTakerw.Qty & " resi " & resi);
          end;
        end;
      end;
    end;
  end;
  return;
end;
*/

procedure CombineStockTake(string item,record StockTakeVc StockTaker,var record StockTakeVc resStockTaker)
begin
  Integer i,rwcnt;
  Integer resi,resrwcnt;
  row StockTakeVc StockTakerw;
  row StockTakeVc resStockTakerw;
  string 255 variety;
  Boolean found;
  
  rwcnt = MatRowCnt(StockTaker);
  for (i=0;i<rwcnt;i=i+1) begin
    MatRowGet(StockTaker,i,StockTakerw);
    variety = right(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(item));
//    if (item==Left(StockTakerw.ArtCode,len(StockTakerw.ArtCode)-len(variety))) then begin incorrect when items are 50000 and 50000A on same stocktaking record
    if (TestArtCodeMatch(StockTakerw.ArtCode,item)) then begin
      resrwcnt = MatRowCnt(resStockTaker);
      if (resrwcnt==0) then begin
        CopyRow(StockTaker,StockTakerw,resStockTakerw);
        MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
      end else begin
        found = false;
        for (resi=0;resi<resrwcnt;resi=resi+1) begin
          MatRowGet(resStockTaker,resi,resStockTakerw);
          if (StockTakerw.ArtCode==resStockTakerw.ArtCode) and (StockTakerw.SerialNr==resStockTakerw.SerialNr) and (StockTakerw.Position==resStockTakerw.Position) then begin
            resStockTakerw.Qty = resStockTakerw.Qty + StockTakerw.Qty;
            resStockTakerw.InStock = resStockTakerw.InStock + StockTakerw.InStock;
            MatRowPut(resStockTaker,resi,resStockTakerw);
            found = true;
            resi = resrwcnt;            
          end;
        end;
        if (found==false) then begin
          CopyRow(StockTaker,StockTakerw,resStockTakerw);
          MatRowPut(resStockTaker,resrwcnt,resStockTakerw);
        end;                
      end;
    end;
  end;
  return;
end;
          
global
procedure FindLastSTForItem(record RcVc RepSpec,string item,Date fromdate,var record StockTakeVc resStockTaker)
begin
  record ItemHistVc IHr;
  record StockTakeVc StockTaker;
  row StockTakeVc StockTakerw;
  record MainStockBlock MSb;
  Boolean TrHs,testf;
  Integer rwcnt,i,keys;
  val t;
  Integer slen;
  string 40 ckey; 
  Date td;
  vector Boolean stocktakef;

  BlockLoad(MSb);
  ckey = "ArtCode";
  keys = 2;
  IHr.ArtCode = item;
  IHr.TransDate = CurrentDate;
  TrHs = true;
  while (LoopBackKey(ckey,IHr,keys,TrHs)) begin
    if (IHr.ArtCode<>item) then begin TrHs = false; end;
    if (IHr.TransDate<fromdate) then begin
      TrHs = false;
    end;            
    if (TrHs) then begin
      if (IHr.FileName=="StockTakeVc") then begin
        StockTaker.SerNr = IHr.TransNr;
        if (ReadFirstMain(StockTaker,1,true)) then begin
          rwcnt = MatRowCnt(StockTaker);
          if ((IHr.Row<rwcnt) and (IHr.Row>-1)) then begin
            MatRowGet(StockTaker,IHr.Row,StockTakerw);
            testf = true;
            if (TestArtCodeMatch(StockTakerw.ArtCode,item)==false) then begin
              testf = false;
            end;            
            if (nonblank(RepSpec.AccStr)) then begin
              if (nonblank(StockTakerw.Location)) then begin
                if (StockTakerw.Location<>RepSpec.AccStr) then begin testf = false; end;
              end else begin
                if (nonblank(StockTaker.Location)) then begin
                  if (StockTaker.Location<>RepSpec.AccStr) then begin testf = false; end;
                end else begin
                  if (MSb.MainStock<>RepSpec.AccStr) then begin testf = false; end;
                end;
              end;
            end;  
            if (IHr.Invalid!=0) then begin testf = false; end;
            if (stocktakef[StockTaker.SerNr]==true) then begin testf = false; end;
            stocktakef[StockTaker.SerNr] = true;
            if (testf) then begin
              CombineStockTake(item,StockTaker,resStockTaker);
            end;
          end;
        end;
      end;
    end;   
  end;  
LFindLastSTForItem:;
  RETURN;
END;
                          
procedure FindLastST(record RcVc RepSpec,string item,Integer SerNrf,Date fromdate,var Date lastdatep,var val unitsp,var val instock,var array val counteda,var array string batcha,var array string posa,var Integer arrcnt,
                     string variety,var record StockTakeVc resStockTaker)
BEGIN
  record ItemHistVc IHr;
  record StockTakeVc StockTaker;
  row StockTakeVc StockTakerw;
  record MainStockBlock MSb;
  Boolean TrHs,testf;
  Integer rwcnt,i,keys;
  val t;
  Integer slen;
  string 40 ckey; 
  Date td;

  instock = blankval;
  lastdatep = td;
  BlockLoad(MSb);
  td = AddYear(td,-GetYear(td));
  if (nonblank(variety)) then begin
    ckey = "ArtCodeVariety";
    keys = 3;
    IHr.Variety = variety;
  end else begin
    ckey = "ArtCode";
    keys = 2;
  end;
    IHr.ArtCode = item;
    IHr.TransDate = CurrentDate;
    TrHs = true;
    while (LoopBackKey(ckey,IHr,keys,TrHs)) begin
      if (IHr.ArtCode<>item) then begin TrHs = false; end;
      if (nonblank(variety)) then begin
        if (IHr.Variety!=variety) then begin TrHs = false; end;
      end;
      if (IHr.TransDate<fromdate) then begin
        TrHs = false;
      end;            
      if (TrHs) then begin
        if (IHr.FileName=="StockTakeVc") then begin
          StockTaker.SerNr = IHr.TransNr;
          if (ReadFirstMain(StockTaker,1,true)) then begin
            rwcnt = MatRowCnt(StockTaker);
            if ((IHr.Row<rwcnt) and (IHr.Row>-1)) then begin
              MatRowGet(StockTaker,IHr.Row,StockTakerw);
              testf = true;
              if (nonblank(variety)) then begin
                if ((item & variety)!=StockTakerw.ArtCode) then begin testf = false; end;
              end else begin
                if (item!=StockTakerw.ArtCode) then begin testf = false; end;
              end;
              if (nonblank(RepSpec.AccStr)) then begin
                if (nonblank(StockTakerw.Location)) then begin
                  if (StockTakerw.Location<>RepSpec.AccStr) then begin testf = false; end;
                end else begin
                  if (nonblank(StockTaker.Location)) then begin
                    if (StockTaker.Location<>RepSpec.AccStr) then begin testf = false; end;
                  end else begin
                    if (MSb.MainStock<>RepSpec.AccStr) then begin testf = false; end;
                  end;
                end;
              end;  
              if (nonblank(RepSpec.LastAcc)) then begin
                if (StockTakerw.Position!=RepSpec.LastAcc) then begin testf = false; end;
              end;
              if (IHr.Invalid!=0) then begin testf = false; end;

              if (testf) then begin
                if (StockTaker.TransDate<>td) then begin
                  t = 0;
                  t = StockTakerw.Qty + t;
                end else begin
                  t = StockTakerw.Qty + t;
                end;
                if (SerNrf==0) then begin
                  if (blank(instock)) then begin
                    instock = StockTakerw.InStock;
                  end;
                end else begin
                  instock = instock + StockTakerw.InStock;
                end;
                if (nonblank(StockTakerw.SerialNr)) then begin
                  batcha[arrcnt] = StockTakerw.SerialNr;
                  counteda[arrcnt] = StockTakerw.Qty;
                  posa[arrcnt] = StockTakerw.Position;
                  arrcnt = arrcnt + 1;
                end;
                td = StockTaker.TransDate;
                lastdatep = StockTaker.TransDate;
                RecordCopy(resStockTaker,StockTaker);
              end;
            end;
          end;
        end;
      end;   
    end;  
LFindLastST:;
  unitsp = t;
/*  
  if (blankdate(lastdatep)) then begin
    TrHs = true;
    StockTaker.TransDate = fromdate;
    while (LoopBackKey("TransDate",StockTaker,1,TrHs)) begin
      if (StockTaker.TransDate<fromdate) then begin
        TrHs = false;
      end;        
      if (TrHs) then begin
        lastdatep = StockTaker.TransDate;
        RecordCopy(resStockTaker,StockTaker);
        TrHs = false;
      end;    
    end;
  end;
*/  
  RETURN;
END;

function Boolean SDPasteArtCode(var record SDVc SDr,record INVc INr,string sernr,Integer rwcnt,Integer loctype,string position)
BEGIN
  Boolean res;
  row SDVc SDrw;
  record INVc locINr;
  
  if (true) then begin
    ClearRow(SDr,SDrw,1);
    SDrw.ArtCode = INr.Code;
    if (ReadFirstItem(SDrw.ArtCode,locINr,true,true)==false) then begin
      goto LSDPasteArtCode;
    end;
    if ((INr.ItemType==2) and (nonblank(INr.Recepy))) then begin
      SDrw.Recepy = INr.Recepy;
    end else begin
      SDrw.Recepy = "";
    end;  
    SDrw.Coefficient = INr.UnitCoefficient;
    SDrw.ArtCode = INr.Code;
    SDrw.Spec = INr.Name;
    SDrw.BasePrice = INr.UPrice1;
    SDrw.Objects = FindINObjects(INr.Objects,INr.Group);
    SDrw.SerialNr = sernr;
    SDrw.PosCode = position;
    if (loctype==1) then begin
      SDrw.CostAcc = GetUsageVarianceAcc(INr.Group,"");
    end;
    MatRowPut(SDr,rwcnt,SDrw);
    res = true;
  end;
LSDPasteArtCode:;  
  SDPasteArtCode = res;
  RETURN;            
END;

procedure SDPasteQty(var record SDVc SDr,record INVc INr,Integer rwcnt,val diff)
BEGIN
  row SDVc SDrw;
  
  MatRowGet(SDr,rwcnt,SDrw);
  SDrw.Qty = -diff;
  if ((INr.ExplodeRec!=0) and (nonblank(SDrw.Recepy))) then begin
//  ExplodeRecepy(SDVc,&INr,&SDrw.Qty,SDp,SDrw.Recepy,row);
    MatRowGet(SDr,rwcnt,SDrw);
    SDrw.Recepy = "";
  end;              
  MatRowPut(SDr,rwcnt,SDrw);
  RETURN;            
END;

//EBS-->
procedure AddToVector(vector string vecData,record INVc INr,val diff,boolean sdf) begin
  integer size;
  
  size = StringToInt(vecData["ARRSIZE"]);
  vecData[size & "::CODE"] = INr.Code; //already with variety
  vecData[size & "::DIFF"] = ValToString(diff,M45Val,"",".",0); 
  if sdf then begin
    vecData[size & "::SDVC"] = "1"; 
  end else begin
    vecData[size & "::SDVC"] = "0";
  end;
  vecData["ARRSIZE"] = size + 1;

return;
end;
//EBS<--

updating           
procedure AddtoSD(vector string vecData,record RcVc RepSpec,var record SDVc SDr,record INVc INr,string sernr,val diff,var Integer flushcnt,record AccBlock ARAccRec,Integer loctype,
                  var Boolean dbupdatedf,boolean torecf,boolean exchangef)
BEGIN
  Integer rwcnt;
  record SDVc oldSDr;
  
  if RepSpec.flags[20]==1 and blank(sernr) and !torecf then begin
    AddToVector(vecData,INr,diff,true);
    GoTo LAddtoSD;
  end;
  
  rwcnt = MatRowCnt(SDr);
  if (rwcnt>=200) then begin
    if exchangef then begin
      SDr.DoNotGenTrans = 1;
    end;
    SDr.TransDate = RepSpec.RegDate;
    SDr.SerNr = NextSerNr("SDVc",SDr.TransDate,-1,false,"");  
    SDr.Location = RepSpec.AccStr;
    SDSumUp(SDr);
    if (blankdate(SDr.TransDate)) then begin SDr.TransDate = CurrentDate; end;
    SDr.CostAcc = ARAccRec.StockLossAcc;
    if (blank(SDr.CostAcc)) then begin
      SDr.CostAcc = ARAccRec.StockGainAcc;
    end;
    SDr.Objects = GetLocationObject(SDr.Location);
    SDr.Comment = RepSpec.f6;
    if (RecordStore(SDr,false)) then begin
    end;
    if ((RepSpec.flags[5]!=0) and !exchangef) or ((RepSpec.flags[21]!=0) and exchangef) then begin //EBS edit
      RecordCopy(oldSDr,SDr);
      SDr.OKFlag = 1;
      if (RecordUpdate(oldSDr,SDr,true)==0) then begin 
        dbupdatedf = true;
      end;
    end;
    CheckFlush(flushcnt,10);
    RecordNew(SDr);
    rwcnt = 0;
  end;
  if (SDPasteArtCode(SDr,INr,sernr,rwcnt,loctype,RepSpec.LastAcc)) then begin
    SDPasteQty(SDr,INr,rwcnt,diff);
  end;
LAddtoSD:;
  RETURN;
END;

function Boolean PUPasteArtCode(record RcVc RepSpec,var record PUVc PUr,record INVc INr,string sernr,Integer rwcnt,record AccBlock ARAccRec,Integer loctype,string position)
BEGIN
  record CostAccBlock CostAccRec;
  record ITVc ITr;
  record PIVc PIr;
  row PUVc PUrw;
  val p;
  string 20 stockacc,purchacc;
  Boolean res;
  record INVc locINr;
  
  BlockLoad(CostAccRec);
  ClearRow(PUr,PUrw,1);
  if (INr.ItemType==1) then begin
    PUrw.ArtCode = INr.Code;
    if (ReadFirstItem(PUrw.ArtCode,locINr,true,true)==false) then begin
      goto LPUPasteArtCode;
    end;
/*
    if (GetFirstPurchaseItem2(PUrw.ArtCode,PUr.Location,PUr.VECode,PIr)) then begin
      PUrw.UPrice = PIr.PurPrice;
      p = PIr.PurPrice;
      if (PIr.PIFactor!=0) then begin
        p = p/PIr.PIFactor;
      end;
      PUrw.PIFactor = PIr.PIFactor;
    end else begin
      PUrw.Spec = INr.Name;
      PUrw.UPrice = INr.InPrice;
      p = INr.InPrice;
      if (INr.PriceFactor!=0) then begin
        p = p/INr.PriceFactor;
      end;
      p = DivRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
      PUrw.PIFactor = INr.PriceFactor;
    end;        
*/    
    PUrw.Spec = INr.Name;
    PUrw.UPrice = INr.InPrice;
    p = INr.InPrice;
    if (INr.PriceFactor!=0) then begin
      p = p/INr.PriceFactor;
    end;
    p = DivRateToBase1(PUr.CurncyCode,p,PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,DefaultCurRoundOff);
    PUrw.PIFactor = INr.PriceFactor;

    PUrw.Coefficient = INr.UnitCoefficient;
    PUrw.Spec = INr.Name;
    PUrw.Objects = FindINObjects(INr.Objects,INr.Group);
    PUrw.UPrice = p;
    PUrw.BasePrice = INr.UPrice1;
    PUrw.Extra = INr.ExtraCost;    
    PUrw.SerialNr = sernr;
    if (blank(PUrw.Location)) then begin
      FindPUStockAcc(PUr.VECode,CostAccRec,PUrw.CostAcc,PUrw.CredAcc,RepSpec.AccStr,INr,PUrw.StockType,stockacc,purchacc,false);
    end else begin
      FindPUStockAcc(PUr.VECode,CostAccRec,PUrw.CostAcc,PUrw.CredAcc,PUrw.Location,INr,PUrw.StockType,stockacc,purchacc,false);
    end;
    PUrw.CostAcc = stockacc;
    PUrw.CredAcc = purchacc;
    // PUrw.CredAcc = ARAccRec.StockGainAcc;//kaido says //EBS not need
    PUrw.UnitCode = INr.Unittext;
    PUrw.ToPosCode = position;
    if (loctype==1) then begin
      PUrw.CredAcc = GetUsageVarianceAcc(INr.Group,PUrw.CredAcc);
    end;
    MatRowPut(PUr,rwcnt,PUrw);
    res = true;
  end;
LPUPasteArtCode:;
  PUPasteArtCode = res;
  RETURN;
END;

procedure PUPasteQty(var record PUVc PUr,record INVc INr,Integer rwcnt,val diff)
BEGIN
  row PUVc PUrw;
  val p,c;
  
  MatRowGet(PUr,rwcnt,PUrw);
  PUrw.Quant = diff;
  PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUr.InclVAT,PUr.NoTAXonVAT,PUrw.Extra,PUr.CurncyCode,
                  PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,
                  PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                  PUrw.CustomsCost,p,PUrw.Quant,c,PUrw.VATCode,PUr.ExportFlag);

  PUrw.CostPrice = p;                                        
  PUrw.Sum = c;                                        
  CalculatePURowSum(PUrw.Quant,PUrw.UPrice,PUrw.Extra,c,PUrw.ShipCost,
                    PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                    PUrw.CustomsCost,p,false,PUr.CurncyCode,
                    PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2);
                                     
  PUrw.Sum = p;
  MatRowPut(PUr,rwcnt,PUrw);
  RETURN;            
END;

updating
procedure AddtoPU(vector string vecData,record RcVc RepSpec,var record PUVc PUr,record INVc INr,string sernr,val diff,var Integer flushcnt,record AccBlock ARAccb,Integer loctype,
                  var Boolean dbupdatedf,boolean torecf,boolean exchangef)
BEGIN
  Integer rwcnt;
  record PUVc oldPUr;
  
  if RepSpec.flags[20]==1 and blank(sernr) and !torecf then begin
    AddToVector(vecData,INr,diff,false);
    GoTo LAddtoPU;
  end;
  
  rwcnt = MatRowCnt(PUr);
  if (rwcnt>=200) then begin
    if exchangef then begin
      PUr.DoNotGenTrans = 1;
    end;
    PUr.TransDate = RepSpec.RegDate;
    PUr.SerNr = NextSerNr("PUVc",PUr.TransDate,-1,false,"");  
    PUr.Location = RepSpec.AccStr;
    PUSumUp(PUr);
    if (blankdate(PUr.TransDate)) then begin PUr.TransDate = CurrentDate; end;
    PUr.Objects = GetLocationObject(PUr.Location);
    PUr.Comment = RepSpec.f6;
    if (RecordStore(PUr,false)) then begin
    end;
    if ((RepSpec.flags[5]!=0) and !exchangef) or ((RepSpec.flags[21]!=0) and exchangef) then begin //EBS edit
      RecordCopy(oldPUr,PUr);
      PUr.OKFlag = 1;
      if (RecordUpdate(oldPUr,PUr,true)==0) then begin 
        dbupdatedf = true;
      end;
    end;
    CheckFlush(flushcnt,10);
    RecordNew(PUr);
    rwcnt = 0;
  end;
  if (PUPasteArtCode(RepSpec,PUr,INr,sernr,rwcnt,ARAccb,loctype,RepSpec.LastAcc)) then begin
    PUPasteQty(PUr,INr,rwcnt,diff);
  end;
LAddtoPU:; //EBS
  RETURN;
END;

//EBS-->
updating
procedure VectorToRecords(vector string vecData,record RcVc RepSpec,var record SDVc SDr,var record PUVc PUr,var record SDVc exSDr,var record PUVc exPUr,
                          boolean varf,var Integer flushcnt,record AccBlock ARAccb,Integer loctype,var Boolean dbupdatedf)
begin
  integer i,size,i2;
  record INVc INr;
  val diff1,diff2,res1,res2,exch1,exch2;  
  
  size = StringToInt(vecData["ARRSIZE"]);
  for(i=0;i<size;i=i+1)begin
    if !varf then begin
      if (ReadFirstItem(vecData[i & "::CODE"],INr,true,true)) then begin
        if vecData[i & "::SDVC"]=="1" then begin
          AddtoSD(vecData,RepSpec,SDr,INr,"",StringToValue(vecData[i & "::DIFF"],M45Val,"","."),flushcnt,ARAccb,loctype,dbupdatedf,true,false);
        end else begin
          AddtoPU(vecData,RepSpec,PUr,INr,"",StringToValue(vecData[i & "::DIFF"],M45Val,"","."),flushcnt,ARAccb,loctype,dbupdatedf,true,false);
        end;
      end;
    end;
    if varf then begin
      diff1 = StringToValue(vecData[i & "::DIFF"],M45Val,"","."); 
      exch1 = StringToValue(vecData[i & "::EXCH"],M45Val,"","."); 
      if (diff1-exch1)!=0 then begin
        res1 = diff1 - exch1;
        for(i2=(i+1);i2<size;i2=i2+1)begin
          diff2 = StringToValue(vecData[i2 & "::DIFF"],M45Val,"",".");
          exch2 = StringToValue(vecData[i2 & "::EXCH"],M45Val,"",".");
          res2 = diff2 - exch2;
          if ((res1<0 and res2>0) or (res1>0 and res2<0)) then begin
            if AbsoluteVal(res1)<=AbsoluteVal(res2) then begin
              vecData[i2 & "::EXCH"] = exch2 - res1;
              vecData[i & "::EXCH"] = exch1 + res1;
              i2 = size;
            end else begin
              vecData[i2 & "::EXCH"] = exch2 + res2;
              vecData[i & "::EXCH"] = exch1 - res2;
              res1 = res1 + res2;
            end;
          end;
        end;
      end;
    end;
  end;
  
  if varf then begin
    for(i=0;i<size;i=i+1)begin
      if (ReadFirstItem(vecData[i & "::CODE"],INr,true,true)) then begin end;
      INr.Code = vecData[i & "::CODE"];
      exch1 = StringToValue(vecData[i & "::EXCH"],M45Val,"","."); 
      diff1 = StringToValue(vecData[i & "::DIFF"],M45Val,"",".");
      diff1 = diff1 - exch1;
      // LogText(0,"ITEM = " & vecData[i & "::CODE"] & " diff1=" & diff1 & " exch1=" & exch1);
      if exch1>0 then begin
        AddtoPU(vecData,RepSpec,exPUr,INr,"",exch1,flushcnt,ARAccb,loctype,dbupdatedf,true,true);
      end;
      if exch1<0 then begin
        AddtoSD(vecData,RepSpec,exSDr,INr,"",exch1,flushcnt,ARAccb,loctype,dbupdatedf,true,true);
      end;
      if diff1>0 then begin
        AddtoPU(vecData,RepSpec,PUr,INr,"",diff1,flushcnt,ARAccb,loctype,dbupdatedf,true,false);
      end;
      if diff1<0 then begin
        AddtoSD(vecData,RepSpec,SDr,INr,"",diff1,flushcnt,ARAccb,loctype,dbupdatedf,true,false);
      end;
    end;
  end;
  
LVectorToRecords:;
return;
end;

function val FindCostPrice(record RcVc RepSpec,string item) begin
  record SDVc SDr;
  row SDVc SDrw;
  integer i,rwc;
  boolean testf,wloop;
  date td;
  val res;
  
  res = blankval;
  td = RepSpec.RegDate;
  if blankdate(td) then begin
    td = CurrentDate;
  end;
  
  SDr.TransDate = td;
  wloop = true;
  While LoopKey("TransDate",SDr,1,wloop) begin
    if SDr.TransDate != td then begin
      wloop = false;
    end else begin
      testf = true;  
      if SDr.DoNotGenTrans != 1 then begin
        testf = false;
      end;
      if SDr.Comment != RepSpec.f6 then begin
        testf = false;
      end;
      if SDr.Location != RepSpec.AccStr then begin
        testf = false;
      end;
      if SDr.OKFlag==0 then begin
        testf = false;
      end;
      if testf then begin
        rwc = MatRowCnt(SDr);
        for(i=0;i<rwc;i=i+1)begin
          MatRowGet(SDr,i,SDrw);
          if (TestArtCodeMatch(SDrw.ArtCode,item)) then begin
            res = SDrw.FIFO;
            GoTo LFindCostPrice;
          end;
        end;
      end;
    end;
  end;
  
LFindCostPrice:;
  FindCostPrice = res;
return;
end;

procedure AddCostFromSD(record PUVc PUr,Record RcVc RepSpec) begin
  row PUVc PUrw;
  integer i,rwc;  
  val p,s,t;

  rwc = MatRowCnt(PUr);
  for(i=0;i<rwc;i=i+1)begin
    MatRowGet(PUr,i,PUrw);
    if nonblank(PUrw.ArtCode) then begin
      t = FindCostPrice(RepSpec,PUrw.ArtCode);
      // LogText(0,"item=" & PUrw.ArtCode & " t=" & t);
      if t!=0 and PUrw.UPrice!=t then begin
        PUrw.UPrice = t;
        MatRowPut(PUr,i,PUrw);
        PUCalcCostPrice(PUrw.ArtCode,PUrw.UPrice,PUr.InclVAT,PUr.NoTAXonVAT,PUrw.Extra,PUr.CurncyCode,
                        PUr.FrRate,PUr.ToRateB1,PUr.ToRateB2,PUr.BaseRate1,PUr.BaseRate2,
                        PUrw.ShipCost,PUrw.RowCost1,PUrw.RowCost2,PUrw.RowCost3,PUrw.RowCost4,PUrw.RowCost5,
                        PUrw.CustomsCost,p,PUrw.Quant,s,PUrw.VATCode,PUr.ExportFlag);
        PUrw.CostPrice = p;
        PUrw.Sum = s;
        MatRowPut(PUr,i,PUrw);    
        PUDchrsum(PUr,i);
        PUSumUp(PUr);
      end;
    end;
  end;
  
  
return;
end;
//EBS<--

updating function Boolean AddSTForThisItem(vector string vecData,record RcVc RepSpec,record INVc INr,string variety,var record SDVc SDr,var record PUVc PUr,var Integer flushcnt,record AccBlock ARAccb,Integer loctype,
                                           var Boolean dbupdatedf)
begin
  val instock,units,diff;
  array val counteda;
  array string 20 batcha;
  array string 255 posa;
  Integer i,arrcnt;
  Date dat1,laststdate;
  Boolean res,found,testf;
  vector Boolean vtreatedf;  
  record INVc IN2r;
  record SerBalVc SerBalr;
  record StockTakeVc StockTaker;
  row StockTakeVc StockTakerw;
  Integer si,srwcnt;  
  record PISVc PISr;
  string 255 serialnr;

  res = true;
  arrcnt = 0;
  FindLastST(RepSpec,INr.Code,INr.SerNrf,RepSpec.RegDate,laststdate,units,instock,counteda,batcha,posa,arrcnt,variety,StockTaker);

  dat1 = laststdate;
  RecordCopy(IN2r,INr);
  IN2r.Code = INr.Code & variety;
  if (RepSpec.flags[3]==3) then begin
    if (blankdate(dat1)) then begin
      res = false;
      goto LAddSTForThisItem;
    end;
  end;
  if (nonblankdate(RepSpec.RegDate)) then begin
    if (RepSpec.RegDate<>dat1) then begin dat1 = RepSpec.RegDate; end;
  end;
  if (blankdate(dat1)) then begin dat1 = CurrentDate; end;
  if (blank(instock)) or (INr.SerNrf!=0) then begin
    if (nonblank(RepSpec.LastAcc)) then begin
      if (blank(RepSpec.AccStr)) then begin
        FindStockValueAtPosition(INr.Code & variety,";;;",RepSpec.LastAcc,PISr);
      end else begin
        FindStockValueAtPosition(INr.Code & variety,RepSpec.AccStr,RepSpec.LastAcc,PISr);
      end;
      instock = PISr.Instock;
      BackDatStock(INr.Code & variety,RepSpec.AccStr,RepSpec.LastAcc,instock,dat1,0);
    end else begin
      instock = GetStockQty(IN2r.Code,RepSpec.AccStr,dat1,false);
    end;
  end;
    
//  if ((blankdate(dat1)) or (units==0)) then begin
  if (blankdate(laststdate)) then begin
    switch (RepSpec.flags[3]) begin    
      case 0:
        units = 0;
        diff = units - instock;
      case 2:
        diff = 0;
      otherwise
        diff = units - instock;
    end;
  end else begin
    diff = units - instock;
  end;
//LogText(0,"1.AddSTForThisItem INr.Code=" & INr.Code & " variety=" & variety & " instock=" & instock & " units=" & units  & " diff=" & diff);

//Trace("","1.AddSTForThisItem INr.Code=" & INr.Code & " variety=" & variety & " instock=" & instock & " units=" & units  & " diff=" & diff & " RepSpec.LastAcc " & RepSpec.LastAcc);
  switch (IN2r.SerNrf) begin
    case 0:
      if (diff<0) then begin
        AddtoSD(vecData,RepSpec,SDr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
      end;     
      if (diff>0) then begin
        AddtoPU(vecData,RepSpec,PUr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
      end;
    case 1:
      if (RepSpec.flags[4]!=0) then begin
        switch (RepSpec.flags[3]) begin
          case 2:
            goto LCASE0;
          case 3:
            goto LCASE0;
          case 0:
LCASE0:;          
            for (i=0;i<arrcnt;i=i+1) begin
              SerBalr.Item = IN2r.Code;
              SerBalr.Location = RepSpec.AccStr;
              SerBalr.Serial = batcha[i];
              if (ReadFirstKey("Serial",SerBalr,3,true)) then begin
                if (counteda[i]==0) then begin
                  if (SerBalr.Quant!=0) then begin
                    AddtoSD(vecData,RepSpec,SDr,IN2r,batcha[i],-1,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
                    diff = diff + 1;
                  end;
                end else begin
//?                
                end;
              end else begin
                AddtoPU(vecData,RepSpec,PUr,IN2r,batcha[i],1,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
                diff = diff - 1;
              end;
            end;
            if (RepSpec.flags[3]!=2) then begin
            dbupdatedf = true;
            while (dbupdatedf) begin
              dbupdatedf = false;
              ResetLoop(SerBalr);
              SerBalr.Item = IN2r.Code;
              SerBalr.Location = RepSpec.AccStr;
              found = true;
              while (LoopMain(SerBalr,2,found)) begin
                if  (SerBalr.Item!=IN2r.Code) then begin 
                  found = false;
                end;
                if (SerBalr.Location!=RepSpec.AccStr) then begin 
                  found = false;
                end; 
                if (diff>=0) then begin
                  found = false;
                end;
                if (found) then begin
                  testf = true;
                  if (SerBalr.Quant==0) then begin
                    testf = false;
                  end;
                  if (vtreatedf[SerBalr.Item & "??" & SerBalr.Serial]==true) then begin
                    testf = false;
                  end;
                  if (testf) then begin
                    for (i=0;i<arrcnt;i=i+1) begin                
                      if (SerBalr.Serial==batcha[i]) then begin
                        i = arrcnt;
                        testf = false;
                      end;
                    end;
                  end;             
                  if (testf) then begin
                    vtreatedf[SerBalr.Item & "??" & SerBalr.Serial] = true;
                    AddtoSD(vecData,RepSpec,SDr,IN2r,SerBalr.Serial,-1,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
                    if (dbupdatedf) then begin
                      found = false;
                    end;
                    diff = diff + 1;
                  end;
                end;
              end;
            end;
            end;
          case 1:
            for (i=0;i<arrcnt;i=i+1) begin
              SerBalr.Item = IN2r.Code;
              SerBalr.Location = RepSpec.AccStr;
              SerBalr.Serial = batcha[i];
              if (ReadFirstKey("Serial",SerBalr,3,true)) then begin
                if (counteda[i]==0) then begin
                  if (SerBalr.Quant!=0) then begin
                    AddtoSD(vecData,RepSpec,SDr,IN2r,batcha[i],-1,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
                    diff = diff + 1;
                  end;
                end else begin
//?                
                end;
              end else begin
                AddtoPU(vecData,RepSpec,PUr,IN2r,batcha[i],1,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
                diff = diff - 1;
              end;
            end;
        end;     
/*            
        if (diff<0) then begin
          ResetLoop(SerBalr);
          SerBalr.Item = IN2r.Code;
          SerBalr.Location = RepSpec.AccStr;
          found = true;
          while (LoopMain(SerBalr,2,found)) begin
            if  (SerBalr.Item!=IN2r.Code) then begin 
              found = false;
            end;
            if (SerBalr.Location!=RepSpec.AccStr) then begin 
              found = false;
            end; 
            if (diff>=0) then begin
              found = false;
            end;
            if (found) then begin
              testf = true;
              if (SerBalr.Quant==0) then begin
                testf = false;
              end;
              if (testf) then begin
                for (i=0;i<arrcnt;i=i+1) begin                
                  if (SerBalr.Serial==batcha[i]) then begin
                    i = arrcnt;
                    testf = false;
                  end;
                end;
              end;             
              if (testf) then begin
                AddtoSD(RepSpec,SDr,IN2r,SerBalr.Serial,-1,flushcnt,ARAccb,loctype,dbupdatedf);
                diff = diff + 1;
              end;
            end;
          end;
        end else begin
          for (i=0;i<arrcnt;i=i+1) begin
            SerBalr.Item = IN2r.Code;
            SerBalr.Location = RepSpec.AccStr;
            SerBalr.Serial = batcha[i];
            if (ReadFirstKey("Serial",SerBalr,3,true)==false) then begin
              AddtoPU(RepSpec,PUr,IN2r,batcha[i],1,flushcnt,ARAccb,loctype,dbupdatedf);
              diff = diff - 1;
            end else begin
              if (counteda[i]==0) then begin
                AddtoSD(RepSpec,SDr,IN2r,batcha[i],-1,flushcnt,ARAccb,loctype,dbupdatedf);
                diff = diff + 1;
              end;
            end;
          end;
        end;    
*/          
      end else begin
        while (diff<>0) begin
          if (diff<0) then begin
            AddtoSD(vecData,RepSpec,SDr,IN2r,"",-1,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
            diff = diff + 1;
          end;     
          if (diff>0) then begin
            AddtoPU(vecData,RepSpec,PUr,IN2r,"",1,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
            diff = diff - 1;
          end;
        end;
      end;
    case 2:
      if (RepSpec.flags[4]!=0) then begin
        if (arrcnt>0) then begin
          for (i=0;i<arrcnt;i=i+1) begin
            instock = STCompFindSerialNrQty(INr.Code,variety,batcha[i],RepSpec.AccStr,posa[i],serialnr);
            diff = counteda[i] - instock;
            if (diff<0) then begin
              AddtoSD(vecData,RepSpec,SDr,IN2r,batcha[i],diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
            end;     
            if (diff>0) then begin
              AddtoPU(vecData,RepSpec,PUr,IN2r,batcha[i],diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
            end;
          end;
        end else begin
          instock = STCompFindSerialNrQty(INr.Code,variety,"",RepSpec.AccStr,RepSpec.LastAcc,serialnr);
          if (diff<0) then begin
            AddtoSD(vecData,RepSpec,SDr,IN2r,serialnr,diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
          end;     
          if (diff>0) then begin
            AddtoPU(vecData,RepSpec,PUr,IN2r,serialnr,diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
          end;
        end;
      end else begin
        if (diff<0) then begin
          AddtoSD(vecData,RepSpec,SDr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
        end;     
        if (diff>0) then begin
          AddtoPU(vecData,RepSpec,PUr,IN2r,"",diff,flushcnt,ARAccb,loctype,dbupdatedf,false,false);
        end;
      end;
  end;
LAddSTForThisItem:;
  AddSTForThisItem = res;
  return;
end;

updating procedure STCompOneItem(record RcVc RepSpec,record INVc INr,var record SDVc SDr,var record PUVc PUr,var record SDVc exSDr,var record PUVc exPUr,var Integer flushcnt,record AccBlock ARAccb,Integer loctype)
BEGIN
  record INVc IN2r;
  string 60 sz,msk,mskrep;
  Boolean varf;
  Boolean TrHs,testf;
  record ItemStatusVc ISr;
  string 200 varsubset;
  Integer keys;
  Boolean dbupdatedf;
  vector Boolean vtreatedf;
  record StockTakeVc combStockTaker;
  row StockTakeVc combStockTakerw;
  Integer combi,combrwcnt;
  string 255 variety,incode,location;
  vector string 255 vecData;
  
  if (INr.ItemType==1) then begin
    if (FindItemVAR(INr.Code,sz,msk,mskrep,varsubset)) then begin varf = true; end;
    if (varf) then begin
      FindLastSTForItem(RepSpec,INr.Code,RepSpec.RegDate,combStockTaker);
      
      dbupdatedf = true;
      while (dbupdatedf) begin
        dbupdatedf = false;

        TrHs = true;
        ResetLoop(ISr);
        ISr.Code = INr.Code;
        keys = 1;
        if (nonblank(RepSpec.AccStr)) then begin
          ISr.Location = RepSpec.AccStr;
          keys = 2;
        end;
        while (LoopMain(ISr,keys,TrHs)) begin    
          if (ISr.Code!=INr.Code) then begin TrHs = false; end;
          if (nonblank(RepSpec.AccStr)) then begin
            if (ISr.Location!=RepSpec.AccStr) then begin
              TrHs = false;
            end;
          end;
          testf = true;
          if (nonblank(RepSpec.AccStr)) then begin
            if (ISr.Location==";;;") then begin
              testf = false;
            end;
          end else begin
            if (ISr.Location!=";;;") then begin
              testf = false;
            end;
          end;
          if (TrHs==false) then begin testf = false; end;
          if (vtreatedf[ISr.Location & "??" & ISr.Variety]==true) then begin
            testf = false;
          end;
          if (testf) then begin
            vtreatedf[ISr.Location & "??" & ISr.Variety] = true;
            if (ReadFirstItem(ISr.Code & ISr.Variety,IN2r,true,true)) then begin
              if (AddSTForThisItem(vecData,RepSpec,IN2r,ISr.Variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
                TrHs = false;
              end else begin
                if (dbupdatedf) then begin
                  TrHs = false;
                end;
              end;
            end;
          end;
        end;  
      end;
      
      if (nonblank(RepSpec.AccStr)) then begin
        location = RepSpec.AccStr;
      end else begin
        location = ";;;";
      end;
      combrwcnt = MatRowCnt(combStockTaker);
      for (combi = 0; combi<combrwcnt; combi = combi + 1) begin
        MatRowGet(combStockTaker,combi,combStockTakerw);
        
        testf = true;
        variety = right(combStockTakerw.ArtCode,len(combStockTakerw.ArtCode)-len(INr.Code));
        incode = left(combStockTakerw.ArtCode,len(INr.Code));
        
        if ((incode!=INr.Code) or (left(variety,1)!=".")) then begin testf = false; end;
        if (testf) then begin
        
          if (vtreatedf[location & "??" & variety]==false) then begin
            vtreatedf[location & "??" & variety] = true;
            
            if (ReadFirstItem(INr.Code & variety,IN2r,true,true)) then begin
              AddSTForThisItem(vecData,RepSpec,IN2r,variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf);
            end;
          end;
        end;
      end;
    end else begin
      if (AddSTForThisItem(vecData,RepSpec,INr,"",SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
        TrHs = false;
      end;
    end;
    if RepSpec.flags[20]==1 then begin //EBS
      VectorToRecords(vecData,RepSpec,SDr,PUr,exSDr,exPUr,varf,flushcnt,ARAccb,loctype,dbupdatedf);
    end;
  end;
  
  return;
end;

updating procedure STCompOneItem_PerPosition(record RcVc orgRepSpec,record INVc INr,var record SDVc SDr,var record PUVc PUr,var record SDVc exSDr,var record PUVc exPUr,var Integer flushcnt,record AccBlock ARAccb,Integer loctype)
begin
  record PISVc PISr;      
  Boolean found;
  record RcVc RepSpec;
  record INVc IN2r;
  Integer combi,combrwcnt;
  record StockTakeVc combStockTaker;
  row StockTakeVc combStockTakerw;
  Integer segs;
  Boolean dbupdatedf,testf;
  vector Boolean vtreatedf;
  string 255 variety,incode;
  vector string 255 vecData;
  
  FindLastSTForItem(orgRepSpec,INr.Code,orgRepSpec.RegDate,combStockTaker);

  dbupdatedf = true;
  while (dbupdatedf) begin
    dbupdatedf = false;

    ResetLoop(PISr);
    found = true;
    PISr.Location = orgRepSpec.AccStr;
    PISr.ArtCode = INr.Code;
    segs = 2;
    if (nonblank(orgRepSpec.LastAcc)) then begin
      PISr.Position = orgRepSpec.LastAcc;
      segs = 3;
    end;
    while (LoopKey("Location",PISr,segs,found)) begin
      if (PISr.Location!=orgRepSpec.AccStr) then begin found = false; end;
      if (PISr.ArtCode!=INr.Code) then begin found = false; end;
      if (nonblank(orgRepSpec.LastAcc)) then begin
        if (PISr.Position!=orgRepSpec.LastAcc) then begin found = false; end;
      end;
      if (found) then begin
        testf = true;
        if (vtreatedf[PISr.Variety & "??" & PISr.Position]==true) then begin
          testf = false;
        end;
        if (testf) then begin
          RecordCopy(RepSpec,orgRepSpec);
          RepSpec.LastAcc = PISr.Position;    
          if (AddSTForThisItem(vecData,RepSpec,INr,PISr.Variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
            found = false;
          end;
          vtreatedf[PISr.Variety & "??" & PISr.Position] = true;
          RemoveFromLastSTForItem(PISr.ArtCode & PISr.Variety,PISr.Position,combStockTaker);
          if (dbupdatedf) then begin
            found = false;
          end;
        end;
      end;
    end;
  end;
  combrwcnt = MatRowCnt(combStockTaker);
  for (combi=0;combi<combrwcnt;combi=combi+1) begin
    MatRowGet(combStockTaker,combi,combStockTakerw);
    testf = true;
    
    variety = right(combStockTakerw.ArtCode,len(combStockTakerw.ArtCode)-len(INr.Code));
    incode = left(combStockTakerw.ArtCode,len(INr.Code));
    if (incode!=INr.Code) then begin testf = false; end;
    if (nonblank(variety)) then begin
      if (left(variety,1)!=".") then begin testf = false; end;
    end;
    if (testf) then begin
      RecordCopy(RepSpec,orgRepSpec);
      RepSpec.LastAcc = combStockTakerw.Position;     
      
      if (ReadFirstItem(INr.Code & variety,IN2r,true,true)) then begin
        if (AddSTForThisItem(vecData,RepSpec,IN2r,variety,SDr,PUr,flushcnt,ARAccb,loctype,dbupdatedf)==false) then begin
          combi = combrwcnt; //??
        end;
      end;
    end;
  end;


  return;
end;

updating procedure STLoopIN(record RcVc RepSpec)
BEGIN
  string 255 ckey;
  Integer keys;
  Boolean testf;
  record INVc INr;
  string 255 fromart,toart;
  string 255 frcc,tocc;
  Boolean TrHs;
  record SDVc SDr,exSDr; //EBS added exSDr
  record PUVc PUr,exPUr; //EBS added exPUr
  Integer flushcnt;
  record AccBlock ARAccb;
  record PUVc oldPUr;
  record SDVc oldSDr;
  record LocationVc Locr;

  Locr.Code = RepSpec.AccStr;
  if (ReadFirstMain(Locr,1,true)) then begin end;
  BlockLoad(ARAccb);
  RecordNew(SDr);
  RecordNew(PUr);
  RecordNew(exSDr);
  RecordNew(exPUr);
  fromart = FirstInRange(RepSpec.f1,20);
  toart = LastInRange(RepSpec.f1,20);
  frcc = FirstInRange(RepSpec.f3,20);
  tocc = LastInRange(RepSpec.f3,20);
  INr.Code = fromart;
  ckey = "Code";
  keys = 1;  
  TrHs = true;
  while (LoopKey(ckey,INr,keys,TrHs)) begin
    testf = true;
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group>tocc) then begin
          if (RepSpec.flags[2]==1) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
    end;        
    if (TrHs) then begin
      if (nonblank(toart)) then begin
        if (INr.Code>toart) then begin
          if (RepSpec.flags[2]==0) then begin
            TrHs = false;
          end else begin
            testf = false;
          end;
        end;
      end;
    end;        
    if (TrHs) then begin
      if (nonblank(RepSpec.f3)) then begin
        if (INr.Group<frcc) then begin
          testf = false;
        end;
      end;
    end;      
    if (nonblank(RepSpec.f4)) then begin
      if (SetInSet2(RepSpec.f4,INr.DispGroups)==false) then begin
        testf = false;
      end;
    end;
    if (nonblank(RepSpec.f5)) then begin
      if (testf==true) then begin
        testf = false;
        ItemClassTypef(RepSpec.f5,INr.DispGroups,testf);
      end;
    end;  
    if (TrHs==false) then begin testf = false; end;
    if (testf) then begin
      if (nonblank(RepSpec.AccStr)) then begin
        if (Locr.RequirePos!=0) then begin
          STCompOneItem_PerPosition(RepSpec,INr,SDr,PUr,exSDr,exPUr,flushcnt,ARAccb,Locr.Type);
        end else begin
          STCompOneItem(RepSpec,INr,SDr,PUr,exSDr,exPUr,flushcnt,ARAccb,Locr.Type);
        end;
      end else begin
        STCompOneItem(RepSpec,INr,SDr,PUr,exSDr,exPUr,flushcnt,ARAccb,Locr.Type);
      end;
    end;
    MaintTrace(INr.Code);
  end;
  if (MatRowCnt(SDr)>0) then begin
    SDr.TransDate = RepSpec.RegDate;
    SDr.SerNr = NextSerNr("SDVc",SDr.TransDate,-1,false,"");  
    SDr.Location = RepSpec.AccStr;
    SDr.Comment = RepSpec.f6;
    SDSumUp(SDr);
    if (blankdate(SDr.TransDate)) then begin SDr.TransDate = CurrentDate; end;
    SDr.CostAcc = ARAccb.StockLossAcc;
    if (blank(SDr.CostAcc)) then begin
      SDr.CostAcc = ARAccb.StockGainAcc;
    end;
    SDr.Objects = GetLocationObject(SDr.Location);
    if (SDr.SerNr>0) then begin
      if (RecordStore(SDr,false)) then begin
      end;  
      if (RepSpec.flags[5]!=0) then begin
        RecordCopy(oldSDr,SDr);
        SDr.OKFlag = 1;
        if (RecordUpdate(oldSDr,SDr,true)==0) then begin 
        end;
      end;
    end;
  end;
  if (MatRowCnt(PUr)>0) then begin
    PUr.TransDate = RepSpec.RegDate;
    PUr.SerNr = NextSerNr("PUVc",PUr.TransDate,-1,false,"");  
    PUr.Location = RepSpec.AccStr;
    PUr.Comment = RepSpec.f6;
    PUSumUp(PUr);
    if (blankdate(PUr.TransDate)) then begin PUr.TransDate = CurrentDate; end;
    PUr.Objects = GetLocationObject(PUr.Location);
    if (PUr.SerNr>0) then begin
      if (RecordStore(PUr,false)) then begin
      end;  
      if (RepSpec.flags[5]!=0) then begin
        RecordCopy(oldPUr,PUr);
        PUr.OKFlag = 1;
        if (RecordUpdate(oldPUr,PUr,true)==0) then begin 
        end;
      end;
    end;
  end;
//EBS-->
  if (MatRowCnt(exSDr)>0) then begin
    exSDr.DoNotGenTrans = 1;
    exSDr.TransDate = RepSpec.RegDate;
    exSDr.SerNr = NextSerNr("SDVc",exSDr.TransDate,-1,false,"");  
    exSDr.Location = RepSpec.AccStr;
    exSDr.Comment = RepSpec.f6;
    SDSumUp(exSDr);
    if (blankdate(exSDr.TransDate)) then begin exSDr.TransDate = CurrentDate; end;
    exSDr.CostAcc = ARAccb.StockLossAcc;
    if (blank(exSDr.CostAcc)) then begin
      exSDr.CostAcc = ARAccb.StockGainAcc;
    end;
    exSDr.Objects = GetLocationObject(exSDr.Location);
    if (exSDr.SerNr>0) then begin
      if (RecordStore(exSDr,false)) then begin
      end;  
      if (RepSpec.flags[21]!=0) then begin
        RecordCopy(oldSDr,exSDr);
        exSDr.OKFlag = 1;
        if (RecordUpdate(oldSDr,exSDr,true)==0) then begin 
        end;
      end;
    end;
  end;
  if (MatRowCnt(exPUr)>0) then begin
    AddCostFromSD(exPUr,RepSpec);
    exPUr.DoNotGenTrans = 1;
    exPUr.TransDate = RepSpec.RegDate;
    exPUr.SerNr = NextSerNr("PUVc",exPUr.TransDate,-1,false,"");  
    exPUr.Location = RepSpec.AccStr;
    exPUr.Comment = RepSpec.f6;
    PUSumUp(exPUr);
    if (blankdate(exPUr.TransDate)) then begin exPUr.TransDate = CurrentDate; end;
    exPUr.Objects = GetLocationObject(exPUr.Location);
    if (exPUr.SerNr>0) then begin
      if (RecordStore(exPUr,false)) then begin
      end;  
      if (RepSpec.flags[21]!=0) then begin
        RecordCopy(oldPUr,exPUr);
        exPUr.OKFlag = 1;
        if (RecordUpdate(oldPUr,exPUr,true)==0) then begin 
        end;
      end;
    end;
  end;
//EBS<--
  RETURN;
END;

global
updating procedure STCompMn(record RcVc RepSpec)
BEGIN
  if (CountRecords("LocationVc")>1) then begin
    if (blank(RepSpec.AccStr)) then begin
      MessageBox(1058," " & USetStr(5010));
      goto LSTCompMn;
    end;
  end;
  if (blankdate(RepSpec.RegDate)) then begin RepSpec.RegDate = CurrentDate; end;
  STLoopIN(RepSpec);  
LSTCompMn:;
  RETURN;
END;
